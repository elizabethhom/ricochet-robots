/**********************************************************
* Comp 15 - Fall 2019
* Project 1: Ricochet Robots!
* ELIZABETH HOM
* 23 OCT 2019
*
* README
*
* README file for gorobots
*********************************************************/

****************
* Compile/run: *
****************
     - Compile using
            make gorobots
     - run executable with
            ./gorobots [board input file]

     - to Compile using testingMain.cpp
            make testing
     - run executable with
            ./testing [board input file]

********************
* Program Purpose: *
********************

This project handles navigating a robot through a maze with the goal of landing
on the target. The program works in two modes: interactive and automatic mode.
Interactive mode allows the user to control the movements of the robot in
search of the target, while automatic mode searches for, and if found, prints a
solution to the puzzle (in 7 steps or less) using a tree that models all the
possible ways the robot can move from its starting position.

*********************
* Acknowledgements: *
*********************

I would like to thank Kevin Destin, the TA who checked me off for part 1 of the
project and ran a tree workshop that was very useful in helping me construct
my tree. I would also like to thank TAs Michael Gold, Radhika Joshi, Nolan
Feeley, Caroline Kaufman, and Juliana Casillo for their immense help throughout
the duration of this project. I would also like to thank Theo Nunez, a past
COMP15 student, who talked through part of my initial design (especially of the
Tree class) with me.

**********
* Files: *
**********

main.cpp:
     Main driver for the robot game. Prompts the user for the robot's symbol
     and starting row and column position. Main.cpp populates the board using
     the file given on the command line, and then runs the remainder of the
     program based on whether the user would like to use the automatic or
     interactive mode of the program.

Board.cpp
	Implementation of the Board class. Holds the game board array, as well as
	functions related to the Board, such as filling the board, printing the
	board, placing the robot in the board.

Board.h:
	Interface of the Board class.

Tree.cpp
    Implementation of the Tree class. Builds a tree that models all the
    possible ways the robot can move from its starting position. After the
    tree is constructed, searches the tree to find a solution to the game in
    7 moves or less.

Tree.h:
    Interface of the Tree class.

testingMain.cpp
    Contains testing code that was used to test whether the key functions in
    Board.cpp were working correctly.

Makefile:
    Contains the code that builds ./gorobots and ./testing using the make
    command.

the_gorobots:
	Reference implementation of the game, Ricochet Robots.

********************
* Data Structures: *
********************

The board class uses a 2D 15x15 character array to represent the game board.
The tree class creates a tree that models all the possible ways the robot can
move from its starting position on the board. The Tree and the Tree class
interacts with the board and Board class to discern the row and col of the
robot at all points/Nodes in the tree, and subsequently the character in the
board at the aforementioned row, col.

************
* Testing: *
************

GENERAL: Unit testing was heavily used to test this program. testingMain.cpp was
used heavily to ensure that they key functions in the Board class were working
correctly, and that all edge cases (such as edges/corners of the board, robot
against '|' and '-' walls, etc) were accounted for. Furthermore, cout
statements were heavily used while debugging, to ensure that variables were
their expected values at each point in the program, which was especially
needed in the construction of the tree and initialization of values (path,
robot row, robot col, board character at specified row, col) of each Node in
the tree.

AUTO: For the AUTOMATIC mode of the program, the outputted solution was
compared against the outputted solution from the reference implementation. When
the two differed, solutionchecker (a program provided by the TAs) was used to
ensure that the solution from the program was indeed a valid solution.

INTER: For the INTERACTIVE mode of the program, testing involved playing the
game myself, and testing as many edge cases as possible (doing the same move
twice, hitting '|' and '-' walls, etc) to ensure the program was working as
expected. The behavior of the program was also compared closely with the
behavior of the reference implementation to ensure that the former was working
correctly.

MEMORY ERRORS: valgrind was heavily used in determining whether there existed
memory errors, and if so, to discern their location.

BUGS ENCOUNTERED: While many bugs were encountered throughout the duratioon of
project 1, a few stand out. Toward the beginning of the project, the program
would consider passing over the target (rather than landing on it) also 
winning the game, which is not the correct behavior and this was noticed while
comparing the behavior of the program against the behavior of the reference
implementation. Additionally, the tree initially was not being constructed
correctly, and this bug was solved by printing out the values in each node to
get a sense of what was truly occurring within the program, and working with
TAs during office hours.

*******************
* Notes/Optional: *
*******************

A bug that still persists in the program is if the robot's initial position is
the same with that of the target, then the program will claim there is "No 
solution" even if its starting position is the solution. However, due to time
constraints, this was not able to be fixed before the deadline.
